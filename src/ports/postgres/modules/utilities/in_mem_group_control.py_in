"""
@file in_mem_group_control.py_in

@brief in-memory grouping controller classes
"""

import plpy
from control import MinWarning
from utilities import unique_string


class GroupIterationController:
    """
    @brief Abstraction for implementing in-memory iteration controller for
    SQL aggregate with STYPE=madlib.bytea8 (e.g. DynamicStruct) in PL/Python

    """

    def __init__(self, arg_dict):
        """
        arg_dict: Dictionary containing arguments to be defined by the calling function:
            Necessary:
                state_type: Type of the transition state
                            (can be double precision[] or <schema_madlib>.bytea8)
                col_dep_var: Name of the dependent column name
                col_ind_var: Name of the independent column name
            Optional:
                col_n_tuples: Name of the column containing count of tuples.
                              Set to a unique string if not defined
        """
        self.schema_madlib = arg_dict['schema_madlib']
        self.in_with = False
        self.iteration = -1
        self.is_group_null = True if arg_dict["grouping_col"] is None else False
        self.kwargs = dict(arg_dict)
        self.kwargs.update(
            state_type=arg_dict.get('state_type', 'double precision[]').format(**arg_dict),
            col_grp_null=unique_string(),
            col_n_tuples=self.kwargs.get('col_n_tuples', unique_string()),
            col_grp_key=self.kwargs.get('col_grp_key', unique_string()),
            grouping_col=("NULL" if arg_dict["grouping_col"] is None
                          else arg_dict["grouping_col"]),
            )
        self.grp_to_n_tuples = {}
        self.new_states = {}
        self.old_states = {}
        self.finished_states = {}
        self.failed_grp_keys = []

        self.is_state_type_bytea8 = False
        if self.kwargs['state_type'] == "{0}.bytea8".format(self.schema_madlib):
            self.is_state_type_bytea8 = True
        elif (self.kwargs['state_type'].lower() == "double precision[]" or
                self.kwargs['state_type'].lower() == "float8[]"):
            self.is_state_type_bytea8 = False
        else:
            plpy.error("Internal error: unexpected state type!")

    def __enter__(self):
        with MinWarning('warning'):
            ############################
            # create state table
            # currently assuming that groups is passed as a valid array
            group_col = ("NULL::integer as {col_grp_null}" if self.is_group_null
                         else "{grouping_col}").format(**self.kwargs)
            groupby_str = ("{col_grp_null}" if self.is_group_null
                           else "{grouping_col}").format(**self.kwargs)
            plpy.execute("""
                DROP TABLE IF EXISTS {rel_state};
                CREATE TEMPORARY TABLE {rel_state} AS (
                    SELECT
                        array_to_string(ARRAY[{grouping_str}], ',') AS {col_grp_key},
                        0::integer                                  AS {col_grp_iteration},
                        NULL::{state_type}                          AS {col_grp_state},
                        count(*)                                    AS {col_n_tuples},
                        {group_col}
                    FROM {rel_source}
                    WHERE ({col_dep_var}) IS NOT NULL
                      AND NOT {schema_madlib}.array_contains_null({col_ind_var})
                    GROUP BY {groupby_str}
                );
                """.format(group_col=group_col,
                           groupby_str=groupby_str,
                           **self.kwargs))

            ############################
            # checking null in group values
            # We cannot allow NULL due to array_to_string cannot handle it well.
            if not self.is_group_null:
                null_test = (" OR ".join([g.strip() + " is NULL" for g in
                             self.kwargs['grouping_col'].split(",")]))
                null_count = plpy.execute("""
                    SELECT count(*) FROM {rel_state} WHERE {null_test}
                    """.format(null_test=null_test,
                               rel_state=self.kwargs['rel_state']))[0]['count']
                if null_count != 0:
                    plpy.error("Grouping error: at least one of the grouping "
                               "columns contains NULL values! Please filter "
                               "out those NULL values.")

            ############################
            # initialize states
            ret_states = plpy.execute("SELECT * FROM " + self.kwargs['rel_state'])
            for state in ret_states:
                self.new_states[state[self.kwargs['col_grp_key']]] = None
                self.grp_to_n_tuples[state[self.kwargs['col_grp_key']]] = \
                    long(state[self.kwargs['col_n_tuples']])

        self.in_with = True
        return self

    def final(self):
        """ Store the final converged state to a table for output """
        if self.is_state_type_bytea8:
            unnest_str = "unnest($1) AS {col_grp_key}, unnest($2) AS {col_grp_state}".format(**self.kwargs)
            grouped_state_type = "{0}.bytea8[]".format(self.kwargs['schema_madlib'])
        else:
            unnest_str = ("grp_key AS {col_grp_key}, state AS {col_grp_state} "
                          "FROM {schema_madlib}._gen_state($1, NULL, $2)".
                          format(**self.kwargs))
            grouped_state_type = "float8[]"

        insert_sql = """
            INSERT INTO {rel_state}
            SELECT
                {col_grp_key},
                {iteration}::int,
                {col_grp_state},
                {col_n_tuples}::bigint,
                {grouping_col}
            FROM (
                    SELECT {grouping_col}, {col_grp_key}
                    FROM {rel_state}
                ) AS _src
            JOIN (
                    SELECT {unnest_str}
                ) AS _rel_state
            USING ({col_grp_key})
            JOIN (
                    SELECT unnest($3) AS {col_grp_key},
                           unnest($4) AS {col_n_tuples}
                ) AS _rel_n_tuples
            USING ({col_grp_key})
            """.format(
                iteration=self.iteration,
                unnest_str=unnest_str,
                **self.kwargs)

        if self.is_state_type_bytea8:
            insert_values = self.finished_states.values()

        else:
            insert_values = [c for state in self.finished_states.values()
                             for c in state]

        insert_plan = plpy.prepare(insert_sql,
                                   ["text[]", grouped_state_type,
                                    "text[]", "bigint[]"])
        plpy.execute(insert_plan, [self.finished_states.keys(),
                                   insert_values,
                                   self.grp_to_n_tuples.keys(),
                                   self.grp_to_n_tuples.values()])
        if self.failed_grp_keys:
            insert_plan = plpy.prepare(insert_sql,
                                       ["text[]", grouped_state_type,
                                        "text[]", "bigint[]"])
            plpy.execute(insert_plan, [self.failed_grp_keys,
                                       [],
                                       self.grp_to_n_tuples.keys(),
                                       self.grp_to_n_tuples.values()])

    def __exit__(self, type, value, tb):
        self.in_with = False

    def test(self, condition):
        """
        Return True if the given expression is TRUE for all in-progress groups.
        Also returns True if there are no groups currently in-progress.

        Evaluate the given expression for all in-progress groups.
        Move groups with expression as True from self.new_states to
        self.finished_states. The expression may depend on the current
        inter-iteration state and all arguments

        @param condition SQL boolean expression. The
            following names are defined and can be used in the condition:
            - \c _args  - The (single-row) argument table
            - \c _state - In memory inter-iteration state
        @return True if \c expression in all non-failed groups is True,
                otherwise False
        """
        if not self.new_states:
            # self.new_states can become empty if the last of the groups failed
            # in the previous update
            return True

        self.is_state_type_bytea8 = False
        if self.kwargs['state_type'] == "{0}.bytea8".format(self.kwargs['schema_madlib']):
            self.is_state_type_bytea8 = True
        elif (self.kwargs['state_type'].lower() == "double precision[]" or
                self.kwargs['state_type'].lower() == "float8[]"):
            self.is_state_type_bytea8 = False
        else:
            plpy.error("Internal error: unexpected state type!")
        if self.is_state_type_bytea8:
            unnest_str_previous = "unnest($1) AS {col_grp_key}, unnest($2) AS _state_previous".format(**self.kwargs)
            unnest_str_current = "unnest($3) AS {col_grp_key}, unnest($4) AS _state_current".format(**self.kwargs)
            grouped_state_type = "{schema_madlib}.bytea8[]".format(**self.kwargs)
        else:
            unnest_str_previous = "grp_key AS {col_grp_key}, state AS _state_previous FROM {schema_madlib}._gen_state($1, NULL, $2)".format(**self.kwargs)
            unnest_str_current = "grp_key AS {col_grp_key}, state AS _state_current FROM {schema_madlib}._gen_state($3, NULL, $4)".format(**self.kwargs)
            grouped_state_type = "float8[]"

        condition = condition.format(iteration=self.iteration, **self.kwargs)
        eval_plan = plpy.prepare("""
            SELECT
                CAST(({condition}) AS BOOLEAN) AS _expression,
                {col_grp_key}
            FROM
            (
                (
                    SELECT {unnest_str_previous}
                ) sub1
                JOIN
                (
                    SELECT {unnest_str_current}
                ) sub2
                USING ({col_grp_key})
            ) subq1
            """.format(condition=condition,
                       unnest_str_current=unnest_str_current,
                       unnest_str_previous=unnest_str_previous, **self.kwargs),
            ["text[]", grouped_state_type] * 2)

        if self.is_state_type_bytea8:
            ret_tuples = plpy.execute(eval_plan,
                                      [self.old_states.keys(),
                                       self.old_states.values(),
                                       self.new_states.keys(),
                                       self.new_states.values()])
        else:
            if self.iteration == 1:
                flatten_agg_states_old = []
            else:
                flatten_agg_states_old = [c for state in self.old_states.values() for c in state]
            ret_tuples = plpy.execute(eval_plan,
                                      [self.old_states.keys(),
                                       flatten_agg_states_old,
                                       self.new_states.keys(),
                                       [c for state in self.new_states.values() for c in state]])

        self.old_states = {}
        for t in ret_tuples:
            if t['_expression']:
                k = t[self.kwargs['col_grp_key']]
                self.finished_states[k] = self.new_states[k]
                del self.new_states[k]

        return len(self.new_states) == 0

    def update(self, newState, **updateKwargs):
        """
        Update the inter-iteration state

        @param newState SQL expression of (or returning) type
            <tt>state_type.kwargs.state_type</tt>. The
            following names are defined and can be used in the condition:
            - \c _args  - The (single-row) argument table
            - \c _state - In memory inter-iteration state
            .
            Note that <tt>{iteration}</tt> will still be the current iteration.
            For instance, it could be used in the expression as a WHERE
            condition: <tt>[...] WHERE _state._iteration = {iteration}</tt>

        This updates the current inter-iteration state to the result of
        evaluating \c newState. If <tt>self.truncAfterIteration</tt> is true,
        this will replace the old state, otherwise the history of all old states
        is kept.
        """

        newState = newState.format(**self.kwargs)
        self.iteration = self.iteration + 1

        groupby_str = "GROUP BY {grouping_col}, {col_grp_key}".format(
                **self.kwargs) if not self.is_group_null else ""
        using_str = "USING ({col_grp_key})".format(
                **self.kwargs) if not self.is_group_null else "ON TRUE"
        if self.is_state_type_bytea8:
            unnest_str = "unnest($1) AS {col_grp_key}, unnest($2) AS {col_grp_state}".format(**self.kwargs)
            grouped_state_type = "{schema_madlib}.bytea8[]".format(**self.kwargs)
        else:
            unnest_str = "grp_key AS {col_grp_key}, state AS {col_grp_state} FROM {schema_madlib}._gen_state($1, NULL, $2)".format(**self.kwargs)
            grouped_state_type = "float8[]"

        n_tuples_unnest_str = "unnest($3) AS {col_grp_key}, unnest($4) AS {col_n_tuples}".format(**self.kwargs)

        update_plan = plpy.prepare(
            """
            SELECT
                {_grp_key} AS {col_grp_key},
                {grouping_col} {as_string},
                {iteration} AS {col_grp_iteration},
                ({newState}) AS {col_grp_state}
            FROM (
                SELECT
                    *,
                    array_to_string(ARRAY[{grouping_str}], ',') AS {col_grp_key}
                FROM {rel_source}
            ) AS _src
            JOIN (
                SELECT {unnest_str}
            ) AS {rel_state}
            {using_str}
            JOIN (
                SELECT
                    {n_tuples_unnest_str}
            ) AS _rel_n_tuples
            {using_str}
            {groupby_str}
            """.format(
                iteration=self.iteration,
                groupby_str=groupby_str,
                using_str=using_str,
                as_string='AS _grp' if self.is_group_null else '',
                _grp_key=("array_to_string(ARRAY[{grouping_str}], "
                          "',')".format(**self.kwargs) if self.is_group_null
                          else self.kwargs['col_grp_key']),
                newState=newState,
                unnest_str=unnest_str,
                n_tuples_unnest_str=n_tuples_unnest_str,
                **self.kwargs),
            ["text[]", grouped_state_type, "text[]", "integer[]"])

        if self.is_state_type_bytea8:
            res_tuples = plpy.execute(update_plan, [self.new_states.keys(),
                                                    self.new_states.values(),
                                                    self.grp_to_n_tuples.keys(),
                                                    self.grp_to_n_tuples.values()])
        else:
            if self.iteration == 1:
                flatten_agg_states = []
            else:
                flatten_agg_states = [c for state in self.new_states.values() for c in state]
            res_tuples = plpy.execute(update_plan, [self.new_states.keys(),
                                                    flatten_agg_states,
                                                    self.grp_to_n_tuples.keys(),
                                                    self.grp_to_n_tuples.values()])

        self.old_states = self.new_states
        self.new_states = {}
        for t in res_tuples:
            if t[self.kwargs['col_grp_state']] is None:
                self.failed_grp_keys.append(t[self.kwargs['col_grp_key']])
            else:
                self.new_states[t[self.kwargs['col_grp_key']]] = \
                        t[self.kwargs['col_grp_state']]
