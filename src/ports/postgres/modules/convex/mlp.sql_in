/* ----------------------------------------------------------------------- *//**
 *
 * @file mlp.sql_in
 *
 * @brief SQL functions for multi-layer perceptron
 * @date June 2012
 *
 *
 *//* ----------------------------------------------------------------------- */

m4_include(`SQLCommon.m4')


CREATE TYPE MADLIB_SCHEMA.mlp_result AS (
        coeff    DOUBLE PRECISION[],
        loss     DOUBLE PRECISION
);

--------------------------------------------------------------------------
-- create SQL functions for IGD optimizer
--------------------------------------------------------------------------
CREATE FUNCTION MADLIB_SCHEMA.mlp_igd_transition(
        state           DOUBLE PRECISION[],
        start_vec       DOUBLE PRECISION[],
        end_vec         DOUBLE PRECISION[],
        previous_state  DOUBLE PRECISION[],
        layer_sizes     INTEGER[],
        stepsize        DOUBLE PRECISION,
        activation      INTEGER,
        is_classification INTEGER)
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE;

CREATE FUNCTION MADLIB_SCHEMA.mlp_igd_merge(
        state1 DOUBLE PRECISION[],
        state2 DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;

CREATE FUNCTION MADLIB_SCHEMA.mlp_igd_final(
        state DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;

/**
 * @internal
 * @brief Perform one iteration of the incremental gradient
 *        method for computing low-rank matrix factorization
 */
CREATE AGGREGATE MADLIB_SCHEMA.mlp_igd_step(
        /* start_vec*/        DOUBLE PRECISION[],
        /* end_vec */         DOUBLE PRECISION[],
        /* previous_state */  DOUBLE PRECISION[],
        /* layer_sizes */     INTEGER[],
        /* stepsize */        DOUBLE PRECISION,
        /* activation */      INTEGER,
        /* is_classification */ INTEGER )(
    STYPE=DOUBLE PRECISION[],
    SFUNC=MADLIB_SCHEMA.mlp_igd_transition,
    m4_ifdef(`GREENPLUM',`prefunc=MADLIB_SCHEMA.mlp_igd_merge,')
    FINALFUNC=MADLIB_SCHEMA.mlp_igd_final,
    INITCOND='{0,0,0,0,0,0,0,0,0,0}'
);
-------------------------------------------------------------------------

CREATE FUNCTION MADLIB_SCHEMA.internal_mlp_igd_distance(
    /*+ state1 */ DOUBLE PRECISION[],
    /*+ state2 */ DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION AS
'MODULE_PATHNAME'
LANGUAGE c IMMUTABLE STRICT;

CREATE FUNCTION MADLIB_SCHEMA.internal_mlp_igd_result(
    /*+ state */ DOUBLE PRECISION[])
RETURNS MADLIB_SCHEMA.mlp_result AS
'MODULE_PATHNAME'
LANGUAGE c IMMUTABLE STRICT;
-------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.mlp_classification(
    source_table      VARCHAR,
    output_table      VARCHAR,
    independent_varname    VARCHAR,
    dependent_varname   VARCHAR,
    hidden_layer_sizes         INTEGER[],
    optimizer_params   VARCHAR,
    activation      VARCHAR
) RETURNS VOID AS $$
    PythonFunctionBodyOnly(`convex', `mlp_igd')
    mlp_igd.mlp(
        schema_madlib,
        source_table,
        output_table,
        independent_varname,
        dependent_varname,
        hidden_layer_sizes,
        optimizer_params,
        activation,
        True
    )
$$ LANGUAGE plpythonu VOLATILE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.mlp_regression(
    source_table      VARCHAR,
    output_table      VARCHAR,
    independent_varname    VARCHAR,
    dependent_varname   VARCHAR,
    hidden_layer_sizes         INTEGER[],
    optimizer_params   VARCHAR,
    activation      VARCHAR
) RETURNS VOID AS $$
    PythonFunctionBodyOnly(`convex', `mlp_igd')
    mlp_igd.mlp(
        schema_madlib,
        source_table,
        output_table,
        independent_varname,
        dependent_varname,
        hidden_layer_sizes,
        optimizer_params,
        activation,
        False
    )
$$ LANGUAGE plpythonu VOLATILE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.mlp_predict(
    model_table      VARCHAR,
    data_table      VARCHAR,
    id_col_name    VARCHAR,
    output_table      VARCHAR,
    pred_type      VARCHAR
) RETURNS VOID AS $$
    PythonFunctionBodyOnly(`convex', `mlp_igd')
    mlp_igd.mlp_predict(
        schema_madlib,
        model_table,
        data_table,
        id_col_name,
        output_table,
        pred_type)
$$ LANGUAGE plpythonu VOLATILE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');


CREATE FUNCTION MADLIB_SCHEMA._predict_mlp_response(
        coeff DOUBLE PRECISION[],
        independent_varname DOUBLE PRECISION[],
        is_classification DOUBLE PRECISION,
        activation_function DOUBLE PRECISION,
        layer_sizes INTEGER[]
    )
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;
